Number: 1
ID: #3219944
Title:IDOR - Scheduled data leak to other accounts By "projectID"

An Insecure Direct Object Reference (IDOR) vulnerability was discovered in the GetNotebookScheduledPaginatedJobs endpoint on backend.singlestore.com. By modifying the projectID parameter in API requests, an authenticated user could access scheduled job information belonging to other users' projects. The API failed to verify whether the requestor had permission to access the specified project.
The vulnerability exposed sensitive information including database names, notebook paths, scheduling details, and infrastructure information. While exploitation required knowledge of valid project IDs, which limited the practical impact, the issue still represented an authorization bypass warranting remediation.


Number: 2
ID: #3020733
Title:IDOR - Email Verification Bypass via Race Condition

Steps to Reproduce
    Create an account using an attacker email: sijojohnson+attacker@wearehackerone.com.
    Verify the account.
    Go to account settings and update the email address to sijojohnson+attacker2@wearehackerone.com.
    Capture the request using a tool like Burp Suite.
    Send the request to Repeater twice and forward the request.
    In Repeater, modify Request 1 by changing the email to the victim's email (e.g., sijojohnson+victim@wearehackerone.com).
    In Request 2, use the attacker's email (sijojohnson+attacker2@wearehackerone.com).
    Group both requests, select Send Group in Parallel, and send the requests.
    Observe the email inbox—both the victim's and attacker's email addresses will receive the same OTP.
    Go to confirmation page displayed, Enter the OTP (both OTP's are same),
    Capture the request, and replace the email with the victim’s email.
    Send the modified request and observe the response.
    The victim’s email address is now successfully verified.

Number: 3
ID:  #3269777
Title: Replayable Password Change Request Across Sessions.

The report describes a vulnerability in the password change endpoint (PUT /authentication/password) that allows for replay attacks. An attacker who captures a valid password change request can reuse the exact same request later, even from a different session or device, to reset the password again. This vulnerability persists across session renewals and does not require fresh CSRF tokens, timestamps, or other anti-replay mechanisms.
Steps to Reproduce

Log in as a user in Browser A using valid credentials.
Intercept the password change request in Burp Suite.
Send the captured request to Burp Repeater and save it for later use.
Logout from Browser A; attempting to replay the request shows "isAuth:False".
Log in again as the same user in another Browser B.
From Burp Repeater, replay the exact same password change request captured in Step 3.
Observe that the request succeeds and the password is changed, even though it originated from a different session, after the old session was logged out, and reused the exact same body and headers.
A video recording (Recording_2025-07-24_154829.mp4) was provided as proof of concept.

Number: F4
ID: #1874836
Title: Rails Debug Mode Enabled On ( https://44.208.145.207/testrail/files.md5)

Ruby on Rails web application running in development mode has been identified on a Malwarebytes server at https://44.208.145.207/testrail/files.md5. Running Rails in development mode exposes sensitive system information that should not be accessible in a production environment. This includes information about middleware components and application root paths that could be leveraged by attackers.

Number: 5
ID: #2855610
Title: Staff with Restricted Permissions Could Access Customer Data After Company Removal
During my research on admin.shopify.com, I discovered that if a customer is associated with a specific company and places an order for that company, but is later removed from the company, staff with restricted company permissions can still access and update the customer's information.

Steps To Reproduce:

    Visit partner dashboard
    Create development store or use existing one.
    Login to admin.shopify.com.
    Invite staff member and assign them Companies > View, Restrict permissions to assigned company locations and customers permissions.
    Create a company and assign a customer to this company.
    Create an order for the company created in step 5 from the customer's account.
    Remove the customer from that company.
    Try to place a personal order with different shipping address for the customer.
    Visit the staff member account's customer tab and see the customer is still present with updated shipping address and is able to manage their personal information as well.

Number: 5
ID: #2855610
Title: Staff with Restricted Permissions Could Access Customer Data After Company Removal
During my research on admin.shopify.com, I discovered that if a customer is associated with a specific 
company and places an order for that company, but is later removed from the company, staff with restricted 
company permissions can still access and update the customer's information.

Steps To Reproduce:

    Visit partner dashboard
    Create development store or use existing one.
    Login to admin.shopify.com.
    Invite staff member and assign them Companies > View, Restrict permissions to assigned company locations and customers permissions.
    Create a company and assign a customer to this company.
    Create an order for the company created in step 5 from the customer's account.
    Remove the customer from that company.
    Try to place a personal order with different shipping address for the customer.
    Visit the staff member account's customer tab and see the customer is still present with updated shipping address 
    and is able to manage their personal information as well.

Number: 6
ID: #3185001
Title: Order More Than Maximum Allowed Quantity

A business logic vulnerability allowed users to bypass product quantity limits (1-20 items) through parameter manipulation. 
While the UI enforced these limits, server-side validation was missing.

Number: 7
ID: #3228888
Title: Account Takeover in Password Reset Function

A critical authentication bypass vulnerability was present in the password reset functionality of the ███████
website at ███████. The vulnerability allowed attackers to take over any user account without requiring 
access to the victim's phone number or the one-time password (OTP) sent via SMS. The security flaw existedin the 
implementation of the "Forgot Password" feature, where the system was designed to send an OTP to a user's registered 
phone number for verification before allowing password reset. However, the vulnerability arose from inadequate server-side 
validation that relied on client-side responses to determine the success of OTP verification. An attacker could intercept the 
server response using a proxy tool and manipulate the response parameters to bypass the OTP verification step entirely. By changing 
the response status from failure to success and modifying the JSON response body, the attacker could proceed to set a new password for
the victim's account without ever receiving or entering the legitimate OTP. This vulnerability was assigned a CVSS score of 9.6 
(Critical) and represented a complete failure of the authentication mechanism designed to protect user accounts during the password 
reset process.

Number: 8
ID: #2130385
Title: Unauthorized Blogs Creation

An unauthorized blog creation vulnerability has been identified on the lichess.org . 
By manipulating certain request and leveraging the session cookies of a different account, 
an attacker can bypass account-specific limitations and create a blog post on an account that is not yet eligible to do so.

Number: 8
ID: #2130385
Title: Unauthorized Blogs Creation

Steps to reproduce:
    1.Open a new account  and attempt to create a blog post, you will face this message below.

    2.Log in with a different browser and  an old account that has the ability to create blog posts , 
    go to create some blog with test data and solve the capatcha, but before click save fire up the burp suite, 
    catch the request and send it to repeater and then drop it

    3.Here ,I Replaced the cookies in the request with the cookeis of  the new account ,I clicked send and response be like:

    4.I coppied the location url and I visited it  in the browser while logged in with the new account.
    https://lichess.org/[The Location Header]

    5.You can see that as a new account we are able to edit the content and submit the form

    6.Verify that the unauthorized blog post is successfully created in the new account



Number: 9
ID: #3250315
Title: .8x8.vc/index.js: Exposed Google Maps API Key Allowing Potential Abuse of Paid Services

We resolved an issue where a Google Maps API key allowed potential unauthorized access to some Google Maps services.
While the API key was intentionally included in client-side code, it lacked proper restrictions to prevent abuse of paid services. 
The potential impact could theoretically lead to API quota consumption and related billing concerns, though actual impact was limited
as no evidence of exploitation was found. Our team promptly validated and addressed the report by implementing appropriate API key 
restrictions where feasible,while accepting other known limitations.

Number: 10
ID: #3221185
Title: Exceed the maximum number of subscribers using Race Condition 

A race condition vulnerability was discovered in the SingleStore control panel that allowed bypassing the maximum limit of five 
subscribers for alerts. By sending multiple concurrent POST requests to the CreateAlertReceivers endpoint with different 
email addresses, an unlimited number of subscribers could be added despite the UI displaying a restriction message.
The vulnerability was validated, triaged, and assigned a Low severity rating by the SingleStore security team.
The issue has been patched and deployed to production.

Number: 11
ID: #3219944
Title: IDOR - Scheduled data leak to other accounts By "projectID"

An Insecure Direct Object Reference (IDOR) vulnerability was discovered in the GetNotebookScheduledPaginatedJobs
endpoint on backend.singlestore.com. By modifying the projectID parameter in API requests, an authenticated user 
could access scheduled job information belonging to other users' projects. The API failed to verify whether the
requestor had permission to access the specified project. The vulnerability exposed sensitive information including 
database names, notebook paths, scheduling details, and infrastructure information. While exploitation required knowledge 
of valid project IDs, which limited the practical impact, the issue still represented an authorization bypass warranting remediation.
This medium-severity issue has been patched by implementing proper authorization checks.


Number: 12
ID: https://x.com/the_IDORminator/status/1985517267191255431
Title: IDOR - Let's do interactive #bugbounty learning.  Path-based IDORs. Fun!

You visit a webpage with your browser, which should be Firefox, at https://www[.]place[.]com/user/12345.  

The webpage forces a client request to
https://api[.]place[.]com/api/v3/users/12345

This request responds with JSON about that user, to populate into your Firefox web browser.  Its sensitive PII.

Let me break down my thought process here.
1] The first thing I do with this in less than 5 seconds, is try the number 12344 in the path. Iterate a bit, make sure you get 401/403s back.  If not, you probably are looking at someone else's PII.  Yay, GG.

2]  I try to change the path to /v1/, /v2/, /v4/.  Remove it entirely too. Sometimes different API versions are less secure.  Those still in development, older ones, etc.

3] Then I run parameters at the end like ../api/v3/users/12345?userId=12344. 
I try every parameter from the JSON response(s). Did the response change? If it changed the parameter did something. Investigate. (Intruder here)

4] I search JS files for "/api/v3/users" or keywords in the path to find where and how the API path was built, or where there may be other API paths. This is usually in the JS.  Sometimes there are deprecated, hidden, or admin APIs laying there.   Then I try all of those. Pivot pivot pivot. 

5] I usually try appending ?, /, #, and/or URL encoded versions of each of these to the end of the API path. Sometimes that results in a bypass. One time I bypassed the security on thousands of APIs using a trailing slash due to ... well... bad code. This trick also works good when the mitigation was a WAF block.

6] Traverse backwards down the API. Check /api/v3/users/, /api/v3/, /api/, -- fuzz for obvious swagger or API schema paths. Add extra slashes, it looks cool. ///api//v3//users///// . Who knows right?

7] Throw a single quote in there, /12345'.  Did it blow up? Add another quote in there, /12345'' - did it un-blow up? Might be SQLi.  Don't try XSS, XSS is stupid.

8] Fuzz the words "users". What else could be there? 

9] Sometimes APIs reserve keywords, like "ALL".  Try things like /users/all instead of /users/12345.  Run the US Websters Dictionary through that path.  Watch case sensitivity, if it uses lower, its probably always lower.  So dont send uppercase stuff to a lowercase API. 

10] If none of this worked, I'm probably on another API at this point. Less than 10 minutes gone. 












