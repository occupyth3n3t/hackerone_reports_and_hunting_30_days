Number: 1
ID: #3219944
Title:IDOR - Scheduled data leak to other accounts By "projectID"

An Insecure Direct Object Reference (IDOR) vulnerability was discovered in the GetNotebookScheduledPaginatedJobs endpoint on backend.singlestore.com. By modifying the projectID parameter in API requests, an authenticated user could access scheduled job information belonging to other users' projects. The API failed to verify whether the requestor had permission to access the specified project.
The vulnerability exposed sensitive information including database names, notebook paths, scheduling details, and infrastructure information. While exploitation required knowledge of valid project IDs, which limited the practical impact, the issue still represented an authorization bypass warranting remediation.


Number: 2
ID: #3020733
Title:IDOR - Email Verification Bypass via Race Condition

Steps to Reproduce
    Create an account using an attacker email: sijojohnson+attacker@wearehackerone.com.
    Verify the account.
    Go to account settings and update the email address to sijojohnson+attacker2@wearehackerone.com.
    Capture the request using a tool like Burp Suite.
    Send the request to Repeater twice and forward the request.
    In Repeater, modify Request 1 by changing the email to the victim's email (e.g., sijojohnson+victim@wearehackerone.com).
    In Request 2, use the attacker's email (sijojohnson+attacker2@wearehackerone.com).
    Group both requests, select Send Group in Parallel, and send the requests.
    Observe the email inbox—both the victim's and attacker's email addresses will receive the same OTP.
    Go to confirmation page displayed, Enter the OTP (both OTP's are same),
    Capture the request, and replace the email with the victim’s email.
    Send the modified request and observe the response.
    The victim’s email address is now successfully verified.

Number: 3
ID:  #3269777
Title: Replayable Password Change Request Across Sessions.

The report describes a vulnerability in the password change endpoint (PUT /authentication/password) that allows for replay attacks. An attacker who captures a valid password change request can reuse the exact same request later, even from a different session or device, to reset the password again. This vulnerability persists across session renewals and does not require fresh CSRF tokens, timestamps, or other anti-replay mechanisms.
Steps to Reproduce

Log in as a user in Browser A using valid credentials.
Intercept the password change request in Burp Suite.
Send the captured request to Burp Repeater and save it for later use.
Logout from Browser A; attempting to replay the request shows "isAuth:False".
Log in again as the same user in another Browser B.
From Burp Repeater, replay the exact same password change request captured in Step 3.
Observe that the request succeeds and the password is changed, even though it originated from a different session, after the old session was logged out, and reused the exact same body and headers.
A video recording (Recording_2025-07-24_154829.mp4) was provided as proof of concept.

Number: F4
ID: #1874836
Title: Rails Debug Mode Enabled On ( https://44.208.145.207/testrail/files.md5)

Ruby on Rails web application running in development mode has been identified on a Malwarebytes server at https://44.208.145.207/testrail/files.md5. Running Rails in development mode exposes sensitive system information that should not be accessible in a production environment. This includes information about middleware components and application root paths that could be leveraged by attackers.

Number: 5
ID: #2855610
Title: Staff with Restricted Permissions Could Access Customer Data After Company Removal
During my research on admin.shopify.com, I discovered that if a customer is associated with a specific company and places an order for that company, but is later removed from the company, staff with restricted company permissions can still access and update the customer's information.

Steps To Reproduce:

    Visit partner dashboard
    Create development store or use existing one.
    Login to admin.shopify.com.
    Invite staff member and assign them Companies > View, Restrict permissions to assigned company locations and customers permissions.
    Create a company and assign a customer to this company.
    Create an order for the company created in step 5 from the customer's account.
    Remove the customer from that company.
    Try to place a personal order with different shipping address for the customer.
    Visit the staff member account's customer tab and see the customer is still present with updated shipping address and is able to manage their personal information as well.

Number: 5
ID: #2855610
Title: Staff with Restricted Permissions Could Access Customer Data After Company Removal
During my research on admin.shopify.com, I discovered that if a customer is associated with a specific 
company and places an order for that company, but is later removed from the company, staff with restricted 
company permissions can still access and update the customer's information.

Steps To Reproduce:

    Visit partner dashboard
    Create development store or use existing one.
    Login to admin.shopify.com.
    Invite staff member and assign them Companies > View, Restrict permissions to assigned company locations and customers permissions.
    Create a company and assign a customer to this company.
    Create an order for the company created in step 5 from the customer's account.
    Remove the customer from that company.
    Try to place a personal order with different shipping address for the customer.
    Visit the staff member account's customer tab and see the customer is still present with updated shipping address 
    and is able to manage their personal information as well.

Number: 6
ID: #3185001
Title: Order More Than Maximum Allowed Quantity

A business logic vulnerability allowed users to bypass product quantity limits (1-20 items) through parameter manipulation. 
While the UI enforced these limits, server-side validation was missing.

Number: 7
ID: #3228888
Title: Account Takeover in Password Reset Function

A critical authentication bypass vulnerability was present in the password reset functionality of the ███████
website at ███████. The vulnerability allowed attackers to take over any user account without requiring 
access to the victim's phone number or the one-time password (OTP) sent via SMS. The security flaw existedin the 
implementation of the "Forgot Password" feature, where the system was designed to send an OTP to a user's registered 
phone number for verification before allowing password reset. However, the vulnerability arose from inadequate server-side 
validation that relied on client-side responses to determine the success of OTP verification. An attacker could intercept the 
server response using a proxy tool and manipulate the response parameters to bypass the OTP verification step entirely. By changing 
the response status from failure to success and modifying the JSON response body, the attacker could proceed to set a new password for
the victim's account without ever receiving or entering the legitimate OTP. This vulnerability was assigned a CVSS score of 9.6 
(Critical) and represented a complete failure of the authentication mechanism designed to protect user accounts during the password 
reset process.

Number: 8
ID: #2130385
Title: Unauthorized Blogs Creation

An unauthorized blog creation vulnerability has been identified on the lichess.org . 
By manipulating certain request and leveraging the session cookies of a different account, 
an attacker can bypass account-specific limitations and create a blog post on an account that is not yet eligible to do so.

Number: 8
ID: #2130385
Title: Unauthorized Blogs Creation

Steps to reproduce:
    1.Open a new account  and attempt to create a blog post, you will face this message below.

    2.Log in with a different browser and  an old account that has the ability to create blog posts , 
    go to create some blog with test data and solve the capatcha, but before click save fire up the burp suite, 
    catch the request and send it to repeater and then drop it

    3.Here ,I Replaced the cookies in the request with the cookeis of  the new account ,I clicked send and response be like:

    4.I coppied the location url and I visited it  in the browser while logged in with the new account.
    https://lichess.org/[The Location Header]

    5.You can see that as a new account we are able to edit the content and submit the form

    6.Verify that the unauthorized blog post is successfully created in the new account



Number: 9
ID: #3250315
Title: .8x8.vc/index.js: Exposed Google Maps API Key Allowing Potential Abuse of Paid Services

We resolved an issue where a Google Maps API key allowed potential unauthorized access to some Google Maps services.
While the API key was intentionally included in client-side code, it lacked proper restrictions to prevent abuse of paid services. 
The potential impact could theoretically lead to API quota consumption and related billing concerns, though actual impact was limited
as no evidence of exploitation was found. Our team promptly validated and addressed the report by implementing appropriate API key 
restrictions where feasible,while accepting other known limitations.

Number: 10
ID: #3221185
Title: Exceed the maximum number of subscribers using Race Condition 

A race condition vulnerability was discovered in the SingleStore control panel that allowed bypassing the maximum limit of five 
subscribers for alerts. By sending multiple concurrent POST requests to the CreateAlertReceivers endpoint with different 
email addresses, an unlimited number of subscribers could be added despite the UI displaying a restriction message.
The vulnerability was validated, triaged, and assigned a Low severity rating by the SingleStore security team.
The issue has been patched and deployed to production.

Number: 11
ID: #3219944
Title: IDOR - Scheduled data leak to other accounts By "projectID"

An Insecure Direct Object Reference (IDOR) vulnerability was discovered in the GetNotebookScheduledPaginatedJobs
endpoint on backend.singlestore.com. By modifying the projectID parameter in API requests, an authenticated user 
could access scheduled job information belonging to other users' projects. The API failed to verify whether the
requestor had permission to access the specified project. The vulnerability exposed sensitive information including 
database names, notebook paths, scheduling details, and infrastructure information. While exploitation required knowledge 
of valid project IDs, which limited the practical impact, the issue still represented an authorization bypass warranting remediation.
This medium-severity issue has been patched by implementing proper authorization checks.


Number: 12
ID: https://x.com/the_IDORminator/status/1985517267191255431
Title: IDOR - Let's do interactive #bugbounty learning.  Path-based IDORs. Fun!

You visit a webpage with your browser, which should be Firefox, at https://www[.]place[.]com/user/12345.  

The webpage forces a client request to
https://api[.]place[.]com/api/v3/users/12345

This request responds with JSON about that user, to populate into your Firefox web browser.  Its sensitive PII.

Let me break down my thought process here.
1] The first thing I do with this in less than 5 seconds, is try the number 12344 in the path. Iterate a bit, make sure you get 401/403s back.  If not, you probably are looking at someone else's PII.  Yay, GG.

2]  I try to change the path to /v1/, /v2/, /v4/.  Remove it entirely too. Sometimes different API versions are less secure.  Those still in development, older ones, etc.

3] Then I run parameters at the end like ../api/v3/users/12345?userId=12344. 
I try every parameter from the JSON response(s). Did the response change? If it changed the parameter did something. Investigate. (Intruder here)

4] I search JS files for "/api/v3/users" or keywords in the path to find where and how the API path was built, or where there may be other API paths. This is usually in the JS.  Sometimes there are deprecated, hidden, or admin APIs laying there.   Then I try all of those. Pivot pivot pivot. 

5] I usually try appending ?, /, #, and/or URL encoded versions of each of these to the end of the API path. Sometimes that results in a bypass. One time I bypassed the security on thousands of APIs using a trailing slash due to ... well... bad code. This trick also works good when the mitigation was a WAF block.

6] Traverse backwards down the API. Check /api/v3/users/, /api/v3/, /api/, -- fuzz for obvious swagger or API schema paths. Add extra slashes, it looks cool. ///api//v3//users///// . Who knows right?

7] Throw a single quote in there, /12345'.  Did it blow up? Add another quote in there, /12345'' - did it un-blow up? Might be SQLi.  Don't try XSS, XSS is stupid.

8] Fuzz the words "users". What else could be there? 

9] Sometimes APIs reserve keywords, like "ALL".  Try things like /users/all instead of /users/12345.  Run the US Websters Dictionary through that path.  Watch case sensitivity, if it uses lower, its probably always lower.  So dont send uppercase stuff to a lowercase API. 

10] If none of this worked, I'm probably on another API at this point. Less than 10 minutes gone. 

Number: 12

ID:
Title: A Comprehensive Guide to Hunting Bugs in User Registration Features "Coffinx Writeup" 
Introduction

Hi everyone, Welcome back! Today, we’re looking into one of the most critical parts of any application: the signup flow. This is the ‘front door’ where user input first hits the database and authentication layer, which makes it a goldmine for bugs. I’m talking about everything from simple logic flaws to critical vulnerabilities.

In this article, I’m going to break down the essential checks I always do when testing registration features. These are practical, battle-tested steps straight from my pentesting methodology to help you spot the vulnerabilities that usually go unnoticed.

Table of Contents

1. Introduction  
2. Duplicate Registration and Account Overwrite  
3. Case Sensitivity and Shadow Account Bypass  
4. Denial of Service Through Large Input Fields  
5. Missing Rate Limiting During Signup  
6. Stored XSS in Registration Fields  
7. Weak or Broken Email Verification  
8. Unsafe Registration Practices (HTTP, Temp Emails)  
9. Weak Password Policies  
10. Path Overwrite and Route Collision  
11. Server-Side Validation Bypass  
12. Hidden or Legacy Registration Endpoints  
13. HTTP Parameter Pollution in Signup  
14. Weak or Predictable Verification Links  
15. Punycode and IDN Homograph Signup Bypass  
16. OTP Verification Brute-Force During Signup  
17. Weak or Reusable Session Tokens  
18. Null Byte Injection in Signup Inputs  
19. Missing Email Confirmation Enforcement  
20. Session Fixation During Signup and Verification  
21. Cache Control Issues in Signup and Verification  
22. Cross-Account IDOR Testing After Signup  
23. Mass-Assignment in JSON-Based Registration Flows 

1. Duplicate Registration / Overwriting Existing Users

This vulnerability occurs when an application fails to enforce unique constraints on user identifiers (typically the email address or username). If an attacker can register a second account using an email address that already exists in the system, it can lead to account takeovers, data corruption, or bypassing business logic restrictions.
Steps to Reproduce:

    Initial Setup: Create a legitimate first account (e.g., email: victim@gmail.com, password: Password123). Log out.
    Re-register: Create a new account using the exact same email (victim@gmail.com) but a different password (e.g., AttackerPass999).
    Verification: Try to log in using victim@gmail.com and the new password (AttackerPass999). If the application allows the process to finish successfully without throwing an “Email already exists” error, you have takeover the original account.

Variation: Case Sensitivity Bypass

Sometimes developers check for duplicates using exact string matching but store data in a case-insensitive collation database.

    Test: If abc@gmail.com exists, try registering as Abc@gmail.com or aBc@gmail.com. If the backend treats these as different during the check but the same during storage, you might trigger an overwrite or create a “shadow” duplicate account.

2. Denial of Service (DoS) at Input Fields

Signup forms accept user input that must be processed, hashed (in the case of passwords), and stored. By supplying excessively long strings, an attacker can force the server to allocate immense resources to process a single request, potentially causing the server to hang or crash (a localized DoS).
Steps to Reproduce:

    Go to the Sign-up form.
    Fill in normal data for most fields.
    In the Password field (or sometimes the Username field), enter an extremely long string of characters (e.g., 10,000+ ‘A’s). You can generate this easily in a text editor or using Python: python -c “print(‘A’*20000)”. and Submit the form.
    Observation: Monitor the response time. If the request hangs for a long time and eventually returns a 500 Internal Server Error, it indicates the server struggled to process the input, suggesting a vulnerability.

3. Lack of Rate Limiting (Mass Assignment)

If there is no limit on how many registration requests can be made from a single IP address or within a specific timeframe, an attacker can automate the creation of thousands of accounts. This can be used to flood the application’s database, send mass spam emails.
Steps to Reproduce:

    Fill out the signup form with generic details and submit it, intercepting the request in a proxy tool like Burp Suite.
    Send the captured POST request to Burp Intruder.
    In the Intruder “Positions” tab, clear existing payload markers. Add markers (§§) around the email parameter value. Example: email=testuser§1§@example.com
    In the “Payloads” tab, choose “Numbers” (e.g., from 1 to 1000) or provide a list of different email addresses and Start the attack.
    Observation: Analyze the results. If you receive a 200 OK (or whatever the success response code is for hundreds of consecutive requests without being blocked or presented with a CAPTCHA, the endpoint lacks rate limiting.

4. Cross-Site Scripting (XSS) in Registration Fields

Signup forms are common vectors for Stored XSS. An attacker injects malicious JavaScript into profile fields (Username, First Name, Last Name, and sometimes even the Email field). This script is saved to the database. The payload executes whenever another user (like an administrator viewing a user list) or the user themselves views the profile.
Common Payloads & Testing Locations:

Text Fields (Username, Name):

“><img src=x onerror=alert(1)>
<svg/onload=confirm(1)>

Email Field:

Some email validators are loose. Try injecting payloads before the @ symbol or using SVG payloads if allowed.

"><svg/onload=confirm(1)>"@x.y
"><svg/onload=prompt(1)>"@x.y

Bypasses: If basic tags are blocked, try varying capitalization (<ScRiPt>), using different event handlers (onmouseover, onsubmit), or encoding the payload.
5. Insufficient Email Verification

Email verification is crucial to ensure the user owns the email address they provided. Attackers often try to bypass this step to access functionality reserved for verified users without actually owning the email.
Bypass Methods:
A. Response Manipulation

The application may rely on a client-side JavaScript check that looks at the server’s response.

    Intercept the response from the server after submitting the signup or clicking a verification link.
    Look for parameters in the JSON response body like “is_verified”: false, “status”: “pending”, or “success”: false.
    Change the values to true/success (e.g., “is_verified”: true).
    Forward the manipulated response to the browser and see if it grants access.

B. Status Code Manipulation

Similar to response manipulation, the client-side might just be looking for a success status code.

    If accessing a protected page redirects you with a 403 Forbidden or 302 Redirect, intercept the response.
    Change the status code from 403 to 200 OK.
    Sometimes you need to remove redirect headers (like Location: /login) as well.

C. Direct/Forced Browsing

The application might only hide links to the post-registration pages rather than actually protecting them on the server side.

    Register an account but do not verify the email.
    Try to guess or force-browse directly to pages that should only be accessible after verification.

Examples:

 /user/dashboard, /account/settings, /onboarding/step2.

D. Email Verification Swap

Some applications generate a verification token based only on the user ID, not the email address. This creates a window where you can swap the email before completing verification.

    Sign up using an attacker-controlled email like attacker@mail.com
    Wait for the confirmation email but don’t open the link yet.
    If the app lets you access profile or account settings before verifying, go there.
    Try changing the account email to victim@mail.com
    The app will now send a fresh verification link to victim@mail.com Ignore it.
    Instead, go back to attacker@mail.com and open the original verification link.

If this verifies victim@mail.com using the older token, the app is vulnerable to an Email Verification Bypass via stale token reuse.
6. Weak Registration Implementation

This category covers general security best practices that are often ignored during the signup process.

    Allows Disposable Email Addresses: The application should block domains from known temporary email providers (e.g., Mailinator, TempMail). Allowing these invites abuse, spam, and ban evasion.
    Registration Form on non-HTTPS: If the signup page is served over HTTP, all data entered including the new password and personal information is transmitted in plaintext and can be intercepted by a Man-in-the-Middle attacker. you can also test by replacing https:// with http:// manually.

7. Weak Password Policy

A signup form must enforce a strong password policy to protect users from brute-force or credential-stuffing attacks later on.
Check for the following weaknesses:

    Easily Guessable Passwords: Does the form accept passwords like 123456, password, qwerty, or admin?
    Username as Password: Does the form allow the password to be identical to the username? This is a very common pattern for lazy users.
    Email as Password: Does it allow the password to be the same as the email address?
    Improper Password Recovery: While technically part of the login flow, the foundation is laid at registration. Ensure the mechanism for future password resets (e.g., security questions set during signup) is secure and not easily guessable.

8. Path Overwrite (Route Collision)

If an application hosts user profiles on the root path (e.g., site.com/{username}), an attacker can potentially “take over” critical system pages by registering a username that matches a system endpoint or filename.
Steps to Reproduce:

    Identify URL Pattern: Confirm that user profiles are accessible directly via target.tld/username.
    Register Reserved Names: Attempt to signup with usernames corresponding to critical pages or files.

    Modern Apps: login, admin, signup, api, dashboard.
    Legacy Apps: index.php, login.php, signup.php, admin.aspx.

3. Verify Overwrite: Navigate to the target URL (e.g., target.tld/login.php).

If your user profile loads instead of the actual login form or system page, you have successfully executed a Route Collision.
9. Server-Side Validation Bypass (Client-Side Only Checks)

A lot of applications rely heavily on client-side validation to enforce rules like password length, allowed characters, field formats, and required inputs. The problem is that anything enforced only in the browser can be bypassed easily with a proxy or a modified request. If the backend isn’t validating properly, attackers can push malformed or dangerous data into the system.
Steps to Reproduce:

    Open the signup page and fill in the fields with any data.
    Intercept the outgoing request using Burp Suite, OWASP ZAP, or a browser extension like Tamper.
    Modify parameters that would normally be blocked by frontend rules.

Examples:

    Empty username or email
    Password shorter than the minimum requirement
    Invalid email format (e.g., test@test, a@b, abc)
    Special characters in fields that normally block them

4. Forward the request to the server.

If the registration still succeeds despite breaking the frontend rules, the server lacks proper validation. This can lead to malformed accounts, stored XSS, broken workflows, or even injection vulnerabilities.
10. Hidden / Unlinked Registration Endpoints

Some applications expose multiple signup endpoints due to older versions, admin flows, mobile APIs or legacy functionality. These endpoints sometimes skip validations, email verification or business logic checks.
Steps to Reproduce:

    Spider or crawl the application.
    Look for endpoints like:

/api/v1/register
/auth/create
/user/create
/legacy/signup
/mobile/register

3. Compare the validation rules between each endpoint.

If any alternate endpoint allows registration without proper checks (like no email verification, no rate limiting, no password rules), it becomes an easy target for abuse.
11. Parameter Pollution in Signup Requests

HTTP Parameter Pollution (HPP) becomes dangerous when the backend doesn’t clearly define how duplicate parameters are handled. Attackers can inject extra parameters to override existing values or sneak values past validation.
Steps to Reproduce:

    Intercept the signup request.
    Add multiple values to the same parameter. Example:

email=victim@gmail.com&email=attacker@gmail.com

3. Forward the request.

If the server picks the wrong value or inconsistently processes it, you may trigger: Account takeover, Bypassed validation, Confusing or corrupted user records..
12. Weak or Predictable Verification Links

Verification links are often predictable or too short, which makes brute forcing possible.
Steps to Reproduce:

    Register a legitimate account and inspect the verification link format.
    Look for patterns like:

    Base64 email
    Short token values
    Incrementing IDs

3. Attempt token manipulation.

If tokens are guessable or not tied to the account securely, attackers can verify accounts they don’t own or hijack the verification flow.
13. Punycode and IDN Homograph Bypass

Internationalized domain names allow characters from different languages. The problem is that many Unicode characters look identical to normal English letters, even though they’re completely different under the hood. This opens the door for signup and password-reset bypasses when apps normalize emails incorrectly.
Quick example:

admin@example.com and аdmin@example.com (Cyrillic “a”) They look the same but represent two different strings. In Punycode format, it becomes something like: xn — dmin-7cd@example.com.

If the app treats both as the same after normalization, you can use the Unicode version during signup or password-reset and take over the legitimate account. For the full walkthrough with screenshots and PoC steps, you can check out the detailed article on this method.


14. OTP Verification Brute-Force During Signup

Platforms that use email or SMS OTP codes during signup often forget to implement strict rate limiting. Without throttling, attackers can brute-force the OTP and verify any unclaimed email or phone number.
Steps to Reproduce:

    Begin a signup flow that sends an OTP.
    Intercept the OTP verification request.
    Test whether you can:

    Send OTP attempts without limits
    Use rapid sequential guesses
    Change IPs and continue guessing

4. Look for HTTP headers or messages indicating lockout.

If OTPs can be brute-forced, an attacker can complete signup for any email or number without owning it. This breaks the trust model of verification entirely.
15. Weak or Reusable Session Tokens During Signup

Many systems issue an initial session token during registration and continue using it through verification, onboarding, and first login. If the token is not regenerated, attackers can preload a session and force victims into it.
Steps to Reproduce:

    Start a signup flow and capture the session cookie.
    Complete verification and onboarding.
    Compare the session token before and after verification.
    Try registering multiple accounts without refreshing your token.
    Attempt to reuse the same token across different accounts or devices.

If the session stays the same, it’s vulnerable to session fixation or hijacking. The signup process becomes a takeover vector.
15. Null Byte Injection (%00) in Signup Inputs

Some backend systems still improperly handle null bytes in strings, causing truncation or unsafe transformations. If validation happens before the null byte but storage happens after, attackers can bypass rules or corrupt user data.
Steps to Reproduce:

    Register using values like: attacker@mail.com%00victim@mail.com or username%00.jpg
    Observe how the backend stores or displays the data.
    Attempt login or verification afterward.

If the backend truncates at the null byte, you can override or break account attributes and occasionally bypass checks entirely.
16. Missing Email Confirmation Enforcement

Some applications allow users to sign up and log in without confirming ownership of their email. This flaw lets attackers register accounts with any email and impersonate other users.
Steps to Reproduce:

    Register using a random email.
    Skip the confirmation link.
    Try logging in directly.
    Attempt actions like profile update or password reset.

If the app treats the account as fully active without verifying the email, it is vulnerable.
17. Session Fixation During Signup & Verification

If the server does not rotate the session ID during signup, attackers can force victims into attacker-controlled sessions and take over their freshly created accounts.
Steps to Reproduce:

    Start a signup flow and save the session ID.
    Complete signup and verification.
    Compare the session ID before and after the process.
    Try accessing the account using the original ID.

If the ID stays the same, the platform is vulnerable to session fixation.
18. Cache Control Issues in Signup & Verification Flows

Certain pages in the signup or verification process may be cached accidentally, revealing sensitive data when using shared devices or browsers.
Steps to Reproduce:

    Complete signup or verification.
    Use the back button or offline mode.
    Inspect cached pages.
    Test private browsing and shared device scenarios.

If OTP screens, tokens, or verification status pages appear from cache, the application mishandles caching.
19. Cross-Account IDOR Test After Signup

During signup, onboarding endpoints often lack strict access control. Testing with two fresh accounts exposes IDOR issues.
Steps to Reproduce:

    Create two accounts: A and B.
    While both are in early signup or onboarding stages, capture API calls.
    Replace IDs or emails from A with B.
    Try updating or viewing each other’s onboarding steps.

If one account can modify or view another’s data, the signup flow is vulnerable to IDOR attacks.
20. Finding Mass-Assignment Bugs in JSON-Based Registration Flows

APIs that accept JSON during registration are particularly prone to mass-assignment and parameter tampering issues. Attackers can add unexpected fields or alter parameter shapes and casing to influence server-side logic (for example, granting themselves elevated roles, joining organizations, or bypassing verification). I’ve covered all the JSON-based signup manipulation techniques in the next article,

so you can dive deeper there.

    This Article Comming soon..

Conclusion

A signup flow might look simple, but it carries a lot of hidden risks. By checking for things like duplicate accounts, missing rate limits, weak passwords, and broken verification steps, you can catch the vulnerabilities that usually go unnoticed. A solid registration system sets the tone for the app’s overall security, so tightening it early makes everything more reliable.
Disclaimer

    The content provided in this article is for educational and informational purposes only. Always ensure you have proper authorization before conducting security assessments. Use this information responsibly.











